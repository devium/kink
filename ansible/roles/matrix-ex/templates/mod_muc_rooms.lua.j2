local json = require "util.json";
local array = require "util.array";

local have_async = pcall(require, "util.async");
if not have_async then
    module:log("error", "requires a version of Prosody with util.async");
    return;
end

local async_handler_wrapper = module:require "util".async_handler_wrapper;
local tostring = tostring;

function handle_get_all_rooms(event)
    local raw_rooms = array();

    local component = hosts["{{ matrix_jitsi_xmpp_muc_domain }}"];
    if component then
        local muc = component.modules.muc
        if muc and rawget(muc, "all_rooms") then
            raw_rooms = muc.all_rooms();
        end
    end

    local rooms_json = array();

    for room in raw_rooms do
        -- Hide rooms starting with the specified prefix.
        if string.sub(room.jid, 1, string.len("{{ matrix_jitsi_unlisted_room_prefix }}")) ~= "{{ matrix_jitsi_unlisted_room_prefix }}" then
            local room_jid = room.jid;
            local participant_count = 0;
            local occupants_json = array();
            local occupants = room._occupants;
            if occupants then
                for _, occupant in room:each_occupant() do
                    -- Filter focus as we keep it as hidden participant
                    if string.sub(occupant.nick,-string.len("/focus"))~="/focus" then
                        for _, pr in occupant:each_session() do
                            participant_count = participant_count + 1;
                            local nick = pr:get_child_text("nick", "http://jabber.org/protocol/nick") or "";
                            local email = pr:get_child_text("email") or "";
                            occupants_json:push({
                                jid = tostring(occupant.nick),
                                email = tostring(email),
                                display_name = tostring(nick)});
                        end
                    end
                end
            end

            rooms_json:push({
                jid = room_jid,
                participant_count = participant_count,
                participants = occupants_json
            });

        end
    end

    -- create json response
    headers = {
        content_type = "application/json",
        access_control_allow_origin = "*"
    };
    return { status_code = 200; body = json.encode(rooms_json); headers=headers };
end


function module.load()
    module:depends("http");
    module:provides("http", {
        default_path = "/";
        route = {
            ["GET rooms"] = function (event) return async_handler_wrapper(event, handle_get_all_rooms) end;
        };
    });
end
